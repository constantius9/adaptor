\section{Инструментарий коллективной оптимизации программ}
% TODO


\subsection{Расширяемость инструментария}
Инструментарий должен обеспечивать расширяемость в смысле возможности добавления новых модулей сборки, запуска и анализа данных. Это должно обеспечиваться описанием взаимодействия различных модулей системы. На данный момент эта задача не решается, поскольку более важным является получение результатов хотя бы на ограниченном множестве программ с фиксированным набором модулей сборки, запуска и анализа. На данный момент введение обобщённой архитектуры является преждевременным.


\subsection{Платформа для использования инструментария}
В идеальном варианте инструментарий должен поддерживать максимальное число различных программно-аппаратных платформ, как настольных, так и мобильных.

На начальном этапе инструментарий поддерживает ОС Linux на x86-совместимом процессоре ввиду распространённости данной аппаратной платформы, а также удобства разработки и ведения исследований под Linux.


\subsection{Эксперимент по оптимизации программы}
Эксперимент состоит в следующем.

\begin{enumerate}
	\item Система собирает программу с определёнными настройками сборки. В случае компилятора gcc они включают в себя \cite{gcc-options}:

	\begin{enumerate}
		\item компилятор (команда для запуска);
		\item базовый уровень оптимизации (флаг '-O[n]', где n --- уровень оптимизации);
		\item набор флагов тонких настроек оптимизации (флаги семейства '-f[name]', где name --- имя определённого набора оптимизаций). Некоторые из этих флагов также имеют числовые параметры;
		\item путь к заголовочным файлам (опция '-I');
		\item путь к исходным файлам;
		\item параметры определения макросов (флаги вида '-D[MACRO]', где MACRO --- имя определяемого макроса);
		\item путь к исполняемому файлу, производимому компилятором.
	\end{enumerate}

	\item Система запускает программу в контролируемом окружении с определёнными настройками запуска и производит измерение интересующих метрик исполнения программы. Они могут включать в себя:

	\begin{enumerate}
		\item полное время исполнения программы;
		\item время исполнения программы по функциям;
		\item полный объём памяти, занимаемой программой и данными;
		\item объём памяти, занимаемой кодом программы;
	\end{enumerate}

	На данный момент нас будет интересовать полное время исполнения.
	Настройки включают в себя:

	\begin{enumerate}
		\item путь к исполняемому файлу;
		\item источник ввода для стандартного потока ввода программы (перенаправление stdin);
		\item потоки вывода для стандартного потока вывода и стандартного потока ошибок программы (перенаправление stdout и stderr соответственно);
		\item аргументы запуска, в т.ч. путь к обрабатываемому файлу данных (например, путь к файлу изображения для программы сжатия изображений).

	\end{enumerate}

	\item Система сохраняет данные о сборке и запуске программы в базу данных для последующего анализа и обработки.
\end{enumerate}


\subsubsection{Время исполнения программы}
Точное измерение времени исполнения программы может представлять сложности ввиду возможных колебаний из-за изменения загрузки системы другими задачами. Принципиально, рекомендуется выполнять эксперименты на системе, не занятой другими задачами. Однако даже в таком случае системные процессы или разница в решениях, принятых планировщиком процессов, могут оказать значительное воздействие на измерение времени.

Для устранения описанных проблем необходимо производить несколько запусков программы с последующей статистической обработкой. Как показывают работы \cite{runs-number}, 5 измерений обычно достаточно для получения достаточной точности.

В случае внешнего измерения времени исполнения влияние оказывают также накладные расходы, связанные с запуском программы из системы. Для их исключения измерять время исполнения лучше изнутри программы и выводить его, например, в стандартный поток ошибок. Таким образом измерение времени производится в пакете тестирования производительности POLYBENCH \cite{polybench}.

% FIXME: Не проверено.
% Однако, введение в систему множественных запусков одной и той же программы вносит погрешность другого рода, связанную с т.н. эффектом "прогрева кэша" процессора \cite{cache-heating}. Для устранения этой погрешности между запусками измеряемой программы необходимо запускать некую программу-"заглушку", которая исполняет в достаточно длинном цикле некие (возможно бессмысленные) операции с целью заполнить кэш процессора своими данными. Стоит отметить, что такая программа будет зависеть от конкретной архитектуры ввиду необходимости учитывать размер кэшей процессора. Мы будем придерживаться источника \cite{cache-clearing} относительно необходимости запуска программы, очищающей кэш.

Помимо отмеченных сложностей, есть сложность измерения маленьких интервалов времени. Если время исполнения программы находится на уровне 1 мс (таково временное разрешение системного вызова Unix 'gettimeofday'), то даже если запускать программу несколько раз, колебания измерений окажутся настолько большими, что сделают результат неточным. Для устранения этой проблемы необходимо выполнять запуски программы с накоплением времени до тех пор, пока колебания измеренного времени не достигнут некоторой фиксированной малой величины, определяемой необходимой точностью измерений. Данный процесс называется калибровкой. Схема алгоритма приведена ниже.

\begin{enumerate}
	\item Положить n = 1.
	\item Запустить программу 10^n раз. Вычислить дисперсию времени выполнения. Если дисперсия меньше константы \epsilon, закончить работу.
\end{enumerate}


