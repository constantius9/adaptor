\section{Инструментарий коллективной оптимизации программ}
% TODO


\subsection{Репозиторий исходных кодов экспериментальных программ}
Инструментарий выполняет эксперименты по оптимизации над программами, исходный код которых доступен экспериментатору. Экспериментатору должна быть доступна большая база исходных кодов для обеспечения возможности производить эксперименты над разнообразными программами, среди которых должны быть и похожие между собой. Последнее требование нужно ввиду необходимости обнаруживать похожесть программ в их оптимизационном поведении.

В качестве репозитория предлагается использовать сервер распределённой системы контроля версий \cite{distributed-vcs}. Такая архитектура позволяет удобно работать с локальными копиями репозитория при необходимости произвести незначительные изменения для проверки какой-либо гипотезы относительно оптимизационного поведения программ. Она также позволяет отправлять локальные изменения на центральный сервер, что полезно для обмена исходными кодами между экспериментаторами.


\subsubsection{Распределённая система контроля версий Mercurial}

% TODO


\subsubsection{Распределённая система контроля версий Git}

% TODO


\subsection{Расширяемость инструментария}
Инструментарий должен обеспечивать расширяемость в смысле возможности добавления новых модулей сборки, запуска и анализа данных. Это должно обеспечиваться описанием взаимодействия различных модулей системы. На данный момент эта задача не решается, поскольку более важным является получение результатов хотя бы на ограниченном множестве программ с фиксированным набором модулей сборки, запуска и анализа. На данный момент введение обобщённой архитектуры является преждевременным.


\subsection{Платформа для использования инструментария}
В идеальном варианте инструментарий должен поддерживать максимальное число различных программно-аппаратных платформ, как настольных, так и мобильных.

На начальном этапе инструментарий поддерживает ОС Linux на x86-совместимом процессоре ввиду распространённости данной аппаратной платформы, а также удобства разработки и ведения исследований под Linux.


\subsection{Эксперимент по оптимизации программы}
Эксперимент состоит в следующем.

\begin{enumerate}
	\item Система собирает программу с определёнными настройками сборки. В случае компилятора gcc они включают в себя \cite{gcc-options}:

	\begin{enumerate}
		\item компилятор (команда для запуска);
		\item базовый уровень оптимизации (флаг '-O[n]', где n --- уровень оптимизации);
		\item набор флагов тонких настроек оптимизации (флаги семейства '-f[name]', где name --- имя определённого набора оптимизаций). Некоторые из этих флагов также имеют числовые параметры;
		\item путь к заголовочным файлам (опция '-I');
		\item путь к исходным файлам;
		\item параметры определения макросов (флаги вида '-D[MACRO]', где MACRO --- имя определяемого макроса);
		\item путь к исполняемому файлу, производимому компилятором.
	\end{enumerate}

	\item Система запускает программу в контролируемом окружении с определёнными настройками запуска и производит измерение интересующих метрик исполнения программы. Они могут включать в себя:

	\begin{enumerate}
		\item полное время исполнения программы;
		\item время исполнения программы по функциям;
		\item полный объём памяти, занимаемой программой и данными;
		\item объём памяти, занимаемой кодом программы;
	\end{enumerate}

	На данный момент нас будет интересовать полное время исполнения.
	Настройки включают в себя:

	\begin{enumerate}
		\item путь к исполняемому файлу;
		\item источник ввода для стандартного потока ввода программы (перенаправление stdin);
		\item потоки вывода для стандартного потока вывода и стандартного потока ошибок программы (перенаправление stdout и stderr соответственно);
		\item аргументы запуска, в т.ч. путь к обрабатываемому файлу данных (например, путь к файлу изображения для программы сжатия изображений).

	\end{enumerate}

	\item Система сохраняет данные о сборке и запуске программы в базу данных для последующего анализа и обработки.
\end{enumerate}


\subsubsection{Время исполнения программы}
Точное измерение времени исполнения программы может представлять сложности ввиду возможных колебаний из-за изменения загрузки системы другими задачами. Принципиально, рекомендуется выполнять эксперименты на системе, не занятой другими задачами. Однако даже в таком случае системные процессы или разница в решениях, принятых планировщиком процессов, могут оказать значительное воздействие на измерение времени.

Для устранения описанных проблем необходимо производить несколько запусков программы с последующей статистической обработкой. Как показывают работы \cite{runs-number}, 5 измерений обычно достаточно для получения достаточной точности.

В случае внешнего измерения времени исполнения влияние оказывают также накладные расходы, связанные с запуском программы из системы. Для их исключения измерять время исполнения лучше изнутри программы и выводить его, например, в стандартный поток ошибок. Таким образом измерение времени производится в пакете тестирования производительности POLYBENCH \cite{polybench}.

Внутреннее измерение времени исполнения обеспечивает большую точность, однако, оно требует поддержки на уровне исходного кода. Очевидно, что для универсального инструментария запуска оптимизационных экспериментов такое решение неприемлемо, поскольку должно быть возможно измерение времени выполнения программ, никак специально не подготовленных для этого.

По этой причине система измеряет время исполнения извне. Невысокая точность измерения при этом устраняется с помощью калибровки (см. ниже). При этом также стоит отметить, что погрешность, вносимая внешним измерением, является систематической и не оказывает влияния на относительное время выполнения разных версий программы, что является наиболее важным в данной задаче.

% FIXME: Не проверено.
% Однако, введение в систему множественных запусков одной и той же программы вносит погрешность другого рода, связанную с т.н. эффектом "прогрева кэша" процессора \cite{cache-heating}. Для устранения этой погрешности между запусками измеряемой программы необходимо запускать некую программу-"заглушку", которая исполняет в достаточно длинном цикле некие (возможно бессмысленные) операции с целью заполнить кэш процессора своими данными. Стоит отметить, что такая программа будет зависеть от конкретной архитектуры ввиду необходимости учитывать размер кэшей процессора. Мы будем придерживаться источника \cite{cache-clearing} относительно необходимости запуска программы, очищающей кэш.

Помимо отмеченных сложностей, есть сложность измерения маленьких интервалов времени. Если время исполнения программы находится на уровне 1 мс (таково временное разрешение системного вызова Unix 'gettimeofday'), то даже если запускать программу несколько раз, колебания измерений окажутся настолько большими, что сделают результат неточным. Для устранения этой проблемы необходимо выполнять запуски программы с накоплением времени до тех пор, пока колебания измеренного времени не достигнут некоторой фиксированной малой величины, определяемой необходимой точностью измерений. Данный процесс называется калибровкой. Схема алгоритма приведена ниже.

\begin{enumerate}
	\item Положить n = 1.
	\item Запустить программу 10\^n раз. Вычислить дисперсию времени выполнения. Если дисперсия меньше константы $\epsilon$ и время выполнения многих запусков превысило 10 мсек, сохранить число запусков для последующего использования и закончить работу.
\end{enumerate}


