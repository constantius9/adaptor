\chapter{Проверка оптимизаций, сохраняющих структуру программы}

Опишем стратегию \emph{voc} и теорию валидации оптимизаций.

Компилятор получает на вход \emph{исходную программу}, написанную на высокоуровневом языке, преобразует её в \emph{промежуточное представление} и затем применяет набор оптимизаций к программе --- начиная с классических глобальных оптимизаций, независящих от архитектуры, и заканчивая архитектурно-зависимыми, такими, как распределение регистров и планирование инструкций. Обычно эти оптимизации производятся в несколько проходов (до 15 в некоторых компиляторах), и каждый проход применяет оптимизацию определённого типа.

Для того, чтобы доказать, что целевой код является корректной трансляцией исходного кода, разберём сначала некоторые необходимые термины. Целевой код \emph{T} является корректной трансляцией исходного кода \emph{S}, если вычисление кода \emph{T} с некоторыми значениями переменных эквивалентно вычислению кода \emph{S} с некоторыми другими значениями переменных.

Промежуточное представление --- это трёхадресный код. Он описан \emph{графом потока}, что является графовым представлением трёхадресного кода. Каждый узел в графе потока представляет собой \emph{линейный участок}, то есть последовательность операторов, не содержащую ветвлений. Границы линейного участка определяются потоком управления.

\section{Системы преобразований}

Для представления формальных понятий исходного и промежуточного кода вводится понятие \emph{системы преобразований} (англ. transition systems, $TS$), вариант аналогичного понятия, упомянутого в \cite{PSS98b}. Система преобразований $S = \left\langle  V, O, \Theta, \rho \right\rangle $ --- конечный автомат, состоящий из:
\begin{itemize}
\item $V$ --- множество переменных состояния,
\item $O \subseteq V$ --- множество наблюдаемых переменных состояния,
\item $\Theta$ --- начальное состояние системы,
\item $\rho$ --- правила перехода, сопостовляющие исходное и результирующее состояние.
\end{itemize}

Значение, получаемое переменной $x$ в состоянии $s$, обозначается $s[x]$. Правило перехода $y' = y + 1$ означает, что в новом состоянии значение переменной $y$ на 1 больше, чем в старом.

Наблюдаемыми считаются все переменные, значение которых выводится на внешние устройства в результате работы программы.

Система переходов называется детерминированной, если начальное состояние однозначно определяет дальнейший ход вычислений. Мы рассматриваем валидацию только таких программ.

Определим $P_{s} = \left\langle  V_{s}, O_{s}, \Theta_{s}, \rho_{s} \right\rangle $ и $P_{t} = \left\langle  V_{t}, O_{t}, \Theta_{t}, \rho_{t} \right\rangle $ как исходную и целевую систему переходов, соответственно. Они называются сравнимыми, если существует соотношение один-к-одному между наблюдаемыми переменными $P_{s}$ и $P_{t}$. Обозначим $ X \subset O_{s} $ и $ x \subset O_{t} $ соответствующие наблюдаемые переменные. Исходное состояние \emph{совместимо} с целевым, если они оба включают одинаковые множества наблюдаемых переменных. Назовём $P_{t}$ корректной трансляцией $P_{s}$ если они сравнимы и, для каждого вычисления $P_{T}$ $\sigma_{T}: t_{0}, t_{1}, \ldots$ и $P_{S}$ $\sigma_{S}: s_{0}, s_{1}, \ldots $ $s_{0}$ совместимо с $t_{0}$, $\sigma_{T}$ завершается тогда и только тогда, когда $\sigma_{S}$ завершается, и их конечные состояния совместимы.

\section{Валидация трансляции оптимизаций}

Положим $P_{s}$ и $P_{t}$ сравнимыми $TS$. Для формального доказательства корректности преобразования $P_{s}$ в $P_{t}$ введём правило доказательства $Validate$, приведённое ниже. Оно включает в себя установление соответствия потока управления между исходным и целевым кодом и установление соответствия данных между исходным и целевым кодом.

Обе $TS$ имеют множество разрезов $CP$ --- множество участков, включающих начальный и конечный участок и хотя бы один участок из каждого цикла в графе потока управления программы. Простой путь --- путь, соединяющий два места разреза, и не содержащий больше никаких промежуточных узлов. Для каждого простого пути из участка $B_{i}$ в участок $B_{j}$ $\rho_{ij}$ описывает отношение преобразования между участками $B_{i}$ и $B_{j}$.

Инварианты $\phi_{i}$ в части (2) правила --- это аннотации программы, которые должны быть верны при исполнении блока $B_{i}$. Они обычно могут быть получены путём анализа потока данных, который выполняется компилятором.

Условия корректности утверждают, что в каждом переходе из $B_{i}$ в $B_{j}$, при условии соблюдения инварианта $\phi_{i}$ и соотношений между переменными, после перехода соблюдается инвариант $\phi_{j}$ и соотношения между переменными сохраняются.

\cite{ZPFG02} содержит обсуждение, доказательство правильности и примеры применения правила.

Далее приводится правило $Validate$.

\begin{quote}
    \begin{enumerate}
        \item Установить соответствие потока управления $CP_{T} \rightarrow CP_{S}$ между начальным и конечным участком в целевом коде и соответствующими участками в исходном коде.
        \item Для каждого участка $B_{i}$ в $CP_{T}$ сформировать инвариант $\phi_{i}$.
        \item Установить соответствие между данными путём присвоения переменным выражения из переменных состояния в целевом коде, зависимых от выполнения предиката над переменными целевого кода.
        \item Для каждой пары линейных участков $B_{i}$ и $B_{j}$, для которых существует простой путь в графе потока управления, создать множество простых путей и условие корректности
        \item Установить верность всех сгенерированных условий корректности.
    \end{enumerate}
\end{quote}

Проверка сгенерированных условий производится с помощью формальных доказателей теорем вроде используемого в \cite{PRSS99}.

Более подробное рассмотрение $Validate$ можно найти в \cite{ZuckPFGH02}.

\chapter{Проверка трансформаций, изменяющих структуру программы}

Трансформация, изменяющая структуру --- любая трансформация, которая изменяет порядок исполнения кода без добавления или удаления операторов \cite{AK02}. Она сохраняет семантику программы в случае сохранения зависимостей между операторами.

\section{Обзор трансформаций, изменяющих структуру программы}

Рассмотрим цикл

\begin{center}
    \begin{quote}
        \begin{verbatim}
            for i1 = 1 to k1 do
                ...
                for im = 1 to km do
                    B1(i1 ,...,im)
                    ...
                    Bl(i1 ,...,im)
                end
                ...
            end
        \end{verbatim}
    \end{quote}
\end{center}

Исполнение такого цикла может быть описано так:

\begin{equation}\label{eq:loop-execution}
    \underbrace{B1(i_{1}), B2(i_{1}), \ldots, B\ell(i_{1}),}_{B(i_{1})} 
    \hspace{4mm} \ldots \hspace{4mm} 
    \underbrace{B1(i_{N}), B2(i_{N}), \ldots, B\ell(i_{N})}_{B(i_{N})}
\end{equation}

Трансформация, изменяющая структуру, вызывает изменение порядка выполнения цикла таким образом, что оно является перестановкой выражения \ref{eq:loop-execution}.

Более подробное рассмотрение оптимизаций, в том числе и преобразующих циклы, можно найти в \cite{ZuckPFGH02,Bacon}.

Преобразования, изменяющие порядок операторов, можно разбить на 2 класса. Первый меняет расположение элементов $B(i)$, но не меняет порядок операторов внутри $B(i)$. Примеры таких преобразований --- обращение цикла, обмен циклов, разворачивание цикла.

Второй класс преобразований изменяет порядок исполнения компонентов $Bj(i)$ внутри $B{i}$, и оставляет в том же порядке переменную итерации $i$. К таким преобразованиям относится слияние циклов.

Большинство работ рассматривает первый класс преобразований. Каждому преобразованию может быть поставлена в соответветсвие характеристическая перестановка, обозначающая соотношение между индексами в исходном коде и целевом коде.
