\chapter{Обзор области}
\section{Технологии компиляторов}
Современный оптимизирующий промышленный компилятор --- сложная программа, состоящая из нескольких модулей \cite{Aho:2006:CPT:1177220}:
\begin{enumerate}
	\item Анализирующая часть
	\begin{enumerate}
		\item Лексический анализатор
		\item Синтаксический анализатор
		\item Семантический анализатор
	\end{enumerate}
	\item Синтезирующая часть
	\begin{enumerate}
		\item Генератор абстрактного синтаксического дерева
		\item Генератор промежуточного представления
		\item Оптимизатор
		\item Генератор исполняемого файла
	\end{enumerate}
\end{enumerate}
\section{Сложность разработки компиляторов}
\section{Подходы к решению проблемы сложности эвристик}
\section{Итеративная компиляция}
\section{Машинное обучение}
\section{Коллективная оптимизация}
Разработка современного оптимизирующего промышленного компилятора --- сложная задача, требующая огромных вложений человеческих ресурсов. Больш\'{а}я часть этой сложности обусловлена необходимостью тонкой настройки эвристических методов оптимизации исполняемого кода (которые в общем случае решаются NP-сложными алгоритмами), производимой вручную путём просмотра генерируемого кода и состояний промежуточного представления компилятора. Не говоря о том, что создание таких эвристик представляет собой зачастую нетривиальную задачу \cite{Lavery:1995:IPC:626512.626987,Abraham:1996:MSR:243846.243903}, эвристики часто имеют противоположные цели --- например, одни оптимизации увеличивают производительность кода ценой размера исполняемого файла (например, разворачивание циклов), а другие уменьшают размер кода, уменьшая производительность. Помимо этого, в компиляторах чаще всего используются упрощённые модели аппаратного обеспечения, не учитывающие многие эффекты даже первого порядка, не говоря уже о побочных эффектах. Более того, сами правила обнаружения случаев, в которых можно оптимизировать код, создаются человеком, что также трудоёмко и является далеко не исчерпывающим способом увеличения производительности результирующего кода.

В то же время, у настроек эвристик есть фокальные точки --- такие настройки оптимизации, при которых достигается оптимум по какому-либо критерию. Эти фокальные точки могут быть найдены с помощью функции цели. Примером задачи, для которой существуют достаточно хорошие целевые функции, является задача распределения регистров.

В итоге проблема нахождения оптимальных настроек эвристики сводится к нахождению хорошей функции цели для этой эвристики. Такая функция должна адекватно описывать воздействие эвристики на получаемый код и при этом быть достаточно просто оптимизируемой. Нахождение таких функций вручную очень сложно, поэтому для этого разумно использовать методики машинного обучения.

 Принципиально задача подбора самих эвристик и их настройки может решаться автоматически, как уже доказали работы \cite{Agakov:2006:UML:1121992.1122412,Bodin98iterativecompilation,FCA2007,Cooper:2005:AAC:1065910.1065921}. 

В существующих компиляторах также стоит проблема подбора оптимальных настроек компиляции для данной конкретной программы. Чаще всего проще ограничиться стандартной настройкой «максимальная производительность», нежели производить трудоёмкий анализ кода, который так же требует квалификации опытного разработчика компилятора и знания о платформе, для которой генерируется исполняемый файл. Эта задача также может решаться автоматически и, в ряде случаев, более эффективно.

Описанные особенности разработки оптимизирующих эвристик показывают необходимость их тонкой настройки под каждую аппаратную платформу, под которую создаёт исполняемый код компилятор. На данный момент это делается или вручную, или путём итеративной компиляции. Итеративная компиляция является по сути простым перебором возможных настроек компилятора и не может быть названа достаточно оперативной методикой работы (подбор настроек для одной программы может занимать недели машинного времени). Основной проблемой итеративной компиляции является большое количество необходимых для обучения запусков компилятора, причём все компиляции одной программы должны производиться с одинаковыми наборами данных на одной и той же архитектуре с помощью одного и того же (вплоть до версии) компилятора. Количество необходимых компиляций составляет десятки и сотни запусков \cite{Kisuki:1999:FSI:646347.690219}. Однако недавние работы в данной области показали возможность увеличить эффективность это способа с помощью машинного обучнния, позволяя обеспечить компилятор возможностью подстраиваться под сложные архитектуры и повысить его производительность относительно классических статических компиляторов —-- т.е. таких, которые не были специально модифицированы для работы с инструментарием машинного обучения \cite{Dubach:2009:PCO:1669112.1669124,Dubach:2008:EPA:1450095.1450103}.

В то же время, предпочтительным является обучение с использованием только производственных запусков компилятора, т.е. без специальных обучающих запусков. Для этого предлагается использовать коллективную оптимизацию, позволяющую пользователям обмениваться данными об успешной оптимизации и не проделывать избыточную работу каждый раз изолированно.

Перед реализацией коллективной оптимизации стоит несколько проблем исследовательского и инженерного характера. Инженерная проблема состоит в создании системы, позволяющей прозрачно переиспользовать накопленные другими пользователями знаний о произведенных компиляциях и отправлять данные о них без дополнительных действий со стороны конечного пользователя компилятора. Исследовательская проблема состоит в изучении воздействия различных оптимизаций на различные факторы получаемых программ, такие, как время исполнения и объём используемой памяти.

Коллективная оптимизация может обеспечить эффективность итеративной компиляции без произведения такого большого количества избыточных запусков компилятора. Одним из успешно применяемых подходов к этой задаче предполагает статистическое сравнение эффективности пар наборов оптимизаций. Недавние работы также обнаружили значительно более высокую важность обучения на различных наборах данных и на различных архитектурах, нежели обучения на различных программах \cite{springerlink:10.1007/11596110:24}. Это опровергает доминировавшую до этого точку зрения на применение машинного обучения в компиляторах.

Помимо рассмотрения результатов исследований воздействия оптимизаций на программы, необходимо решение инженерной задачи: внедрение инструментария в традиционные, простые в использовании (по сравнению с исследовательскими) компиляторы. Частью решения этой задачи является плагин к компилятору GCC, предоставляющий возможности произвольного включения выбранных проходов компилятора и обеспечивающий его взаимодействие с репозиторием кода cTuning.org \cite{Fur2009}. В случае более современного компилятора llvm \cite{llvm} плагин имеет более простую организацию, поскольку данный инструмент имеет встроенные возможности произвольного выбора набора производимых оптимизаций, и нужно обеспечить только взаимодействие с репозиторием cTuning.