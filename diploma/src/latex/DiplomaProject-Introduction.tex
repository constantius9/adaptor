\chapter{Введение}
Разработка современного оптимизирующего промышленного компилятора --- сложная задача, требующая огромных вложений человеческих ресурсов. Больш\'{а}я часть этой сложности обусловлена необходимостью тонкой настройки эвристических методов оптимизации исполняемого кода, производимой вручную путём просмотра генерируемого кода и дампов промежуточного представления структур компилятора. Более того, сами правила обнаружения случаев, в которых можно оптимизировать код, создаются человеком, что также трудоёмко и является далеко не исчерпывающим способом увеличения производительности результирующего кода. Принципиально задача подбора самих эвристик и их настройки может решаться автоматически, как уже доказали работы {}.

В существующих компиляторах также стоит проблема подбора оптимальных настроек компиляции для данной конкретной программы. Чаще всего проще ограничиться стандартной настройкой «максимальная производительность», нежели производить трудоёмкий анализ кода, который так же требует квалификации опытного разработчика компилятора и знания о платформе, для которой генерируется исполняемый файл. Эта задача также может решаться автоматически и, в ряде случаев, более эффективно.

Мы рассмотрим две описанные выше задачи мета-оптимизации компиляторов: задача автоматического подбора наилучших настроек компилятора и задача поиска таких настроек для определённых наборов программ.

Итеративная компиляция способна обеспечить компилятор возможностью быстро подстраиваться под сложные архитектуры и повысить его производительность относительно классических статических компиляторов — т.е. таких, которые не были специально модифицированы для работы с инструментарием машинного обучения ([1], [2], [3]).

Основной проблемой итеративной компиляции является большое количество необходимых для обучения запусков компилятора, причём все компиляции одной программы должны производиться с одинаковыми наборами данных на одной и той же архитектуре с помощью одного и того же (вплоть до версии) компилятора. Количество необходимых компиляций составляет десятки и сотни запусков.

В то же время, предпочтительным является обучения с использованием только производственных запусков компилятора, т.е. без специальных обучающих запусков. Для этого предлагается использовать коллективную оптимизацию, позволяющую пользователям обмениваться данными об успешной оптимизации и не проделывать избыточную работу каждый раз изолированно.

Перед реализацией коллективной оптимизации стоит несколько проблем исследовательского и инженерного характера. Инженерная проблема состоит в создании системы, позволяющей прозрачно переиспользовать накопленные другими пользователями знаний о произведенных компиляциях и отправлять данные о них без дополнительных действий со стороны конечного пользователя компилятора. Исследовательская проблема состоит в изучении воздействия различных оптимизаций на различные факторы получаемых программ, такие, как время исполнения и объём используемой памяти.

Коллективная оптимизация может обеспечить эффективность итеративной компиляции без произведения такого большого количества избыточных запусков компилятора. Применяемый подход предполагает статистическое сравнение эффективности пар наборов оптимизаций. В ходе описываемой работы также была обнаружена значительно более высокая важность обучения на различных наборах данных и на различных архитектурах, нежели обучения на различных программах. Это опровергает доминировавшую до этого точку зрения на применение машинного обучения в компиляторах.

Помимо рассмотрения результатов исследований воздействия оптимизаций на программы, описывается решение инженерной задачи: плагин к компилятору GCC, обеспечивающий его взаимодействие с репозиторием кода cTuning.org [4].